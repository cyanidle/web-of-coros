# Вводная часть

## Тут Первый слайд
### Где работаю
### Чем занимаюсь
### О чем буду говорить
#### О том, как использовать эти страшные корутины
#### Которые появились в С++20 (а должны были в 17!)
### Мне они очень понравились
#### Да нам дали чрезвычайно запутанный и сложный набор инструментов
#### Такой, что 4 года спустя на всех конференциях до сих пор поднимается эта тема как нечто новое
(слайд миллион cppcon/cpp russia talks)
### Я уверен, что они будут полезны многим, давайте посмотрим!
## Зачем они?
### В моей практике я работаю с ВебРТС
### И в в этой практике так случается что в коде события происходят асинхронно
#### Что это значит? 
#### Примеры: запуск субпроцесса, подключение клиента, обмен данными
#### Удаленные вызовы, ответ на которые будет готов потом
### Делается это через коллбеки на низком уровне. 
### На высоком для удобства используется чтото вроде JS Promise
#### Стороняя заметка: строгая типизация и некоторые фичи C++17 очень помогают строго определять действия!
#### Что очень полезно! (nodiscard, constexpr if)
## Жизнь хороша! Пишем бизнесуху!
### Сгущаются тучи if-ов и for-ов (Тут примеры с псевдокодом как хочу / как получилось)
#### При любом ветвлении вспомогательная функция
#### При любом цикле асинхронная рекурсия
##### А мы все знаем, что рекурсия может привести к stack overflow
#### При любой обработке ошибок отделение потока управления
##### Вот бы в плюсах существовал механизм для спасения основного control-flow от ошибок!
##### Дааа, такой что еще и RAII подчищает за собой
#### Скриншот с гига-трейсбэком
## Черт побери, неужели у нас нет инструментов для решения?
### Смотрим на корутины
#### Хочу как в питогнне, джсе <insert lang here>
### Хочу затащить их в проект, заводим экспериментальную веточку
### (здесь выпадаем с тонны текста на cppref)


# Тяжелая часть :

## Распутаем этот клубок, пройдемся по самому важному
## Корутины у нас Стэклесс
### Краткое сравнение со Стэкфул
### Корутины у нас кооперативные
## co_return
## co_yield
## co_await
## Крик подобен грому - дайте людям Coro! (coroutine_type)
### С помощью coro_traits можно подобно hash добавить поддержку чужому типу
## Нужно по любому людям выдать Promise! (promise_type)
## Гостям, конечно, нужен Prom, а он прибудет завтра днём (awaitable)
## coroutine_handle
### is handle.destroy() needed?
## Давайте редис-лайк АПИ превратим в корутину
### Наивно
### Более эффективно через pointer
## Примеры с UB
### Классический 
### Захват аргументов
### await_suspend() other thread pitfall


# Предыстория часть (отдышка):

## Конвей и его закон
## История про перфоленты и огромная цена многопроходного компилятора Кобола
## Через 4 года 70-летний юбилей корутинам!
## И вот мы все пилим и пилим их, может ну его и возьмем готовое
### Давайте посмотрим, что у нас есть по готовым библиотекам


# Библиотечная часть:

## Boost.asio (1.82+)
## Boost.cobalt
## QCoro
### qCoro + timeout overload
### qCoroSignalListener, который превращает сигналы в бесконечный async generator;
## CppCoro - the most standalone


# Заключетельная часть:

## Выводы
### большой набор инструментов
### сам по себе мало полезен
#### (executors TS) - как и все хорошее soon(tm) (пугает меня если честно)
### уже юзабелен для своих целей!
### легко делаем сами (оборачиваем рантайм)
### либо берем библиотечку