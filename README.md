# В паутине корутин

## Зачем

### Все мы хотим писать такой код:
```cpp
task<> tcp_echo_server(tcp::socket socket)
{
    char data[1024];
    while (true) {
        auto n = co_await socket.async_read_some(buffer(data), use_awaitable);
        co_await async_write(socket, buffer(data, n));
    }
}
```
### К сожалению или счастью приходится писать следующее:
```cpp
class EchoServer : std::enable_shared_from_this<EchoServer> {
    char buff[1024];
    tcp::socket sock;
public:
    EchoServer(tcp::socket sock) : sock(std::move(sock)) {}
    void Start() {
        read();
    }
private:
    void read() {
        async_read(sock, buffer(buff), [self = shared_from_this()](auto ec, size_t read){
            if (ec) {
                //todo!
                return; //cannot throw here
            }
            self->write(read);
        });
    }
    void write(size_t amount) {
        async_write(sock, buffer(buff, amount), [self = shared_from_this()](auto ec, size_t){
            if (ec) {
                //todo!
                return; //cannot throw here
            }
            self->read();
        });

    }
};
```
## Предыстория

Мелвин Эдвард Конвей - американский ученый-компьютерщик, программист и хакер, который придумал то, что сейчас известно как закон Конвея: "Организации, разрабатывающие системы, вынуждены создавать проекты, которые являются копиями коммуникационных структур этих организаций". 

Помимо вышеперечисленного, Конвей, пожалуй, наиболее известен благодаря разработке концепции сопрограмм. Конвей ввел термин "сопрограмма" в 1958 году и был первым, кто применил эту концепцию к программе сборки. Позже он написал основополагающую статью на тему сопрограмм под названием "Design of a Separable Transition-diagram".

> Описанные алгоритмы были проверены на компьютере, с памятью в 5000 машинных слов

> Рисунок 3 иллюстрирует суть разделимости. Вместо 
того, чтобы модули A и B взаимодействовали как сопрограммы
со связью сопрограмм между операторами записи в A
и операторами чтения в B, так что управление передается туда
и обратно один раз при каждой передаче элемента, возможно, не изменяя ничего в A или B, кроме связей чтения и
записи, иметь функцию записи в A и B. все его элементы на ленте a, чтобы
перемотать ленту назад и затем попросить B прочитать все элементы с
ленты. Таким образом, в этом смысле пара программ A и B
может работать как однопроходный или двухпроходный процессор с
только тривиальная модификация

> Тем свойством конструкции, которое делает ее пригодной для
многих сегментных конфигураций, является ее разделяемость. Программная
организация является разделимой, если она разбита на
модули обработки, которые взаимодействуют друг с другом в соответствии со
следующими ограничениями: 

1) единственная связь между модулями осуществляется в виде отдельных элементов информации (сообщений) 
2) поток каждого из этих элементов осуществляется по фиксированным односторонним путям 
3) вся программа может быть построена таким образом, что входные данные находятся в крайнем левом углу, выходные - в крайнем левом верхнем углу. крайний правый элемент и все, что находится между ними, все информационные элементы, передаваемые между модулями, имеют движение вправо.


## C++20

Представим сферический проект в вакууме на libuv/Qt или
любом другом фреймворке/библиотеке с асинхроным eventloop.

Чаще всего для индикации завершения операции в высокоуровневых асинхронных рантаймах используется callback функция. Детали не так важны, передается ли некий `void* data` или используется полноценное стирание типов на плюсах или это простой `std::function<>`

И такой код может вполне быть успешным полезным. Я сам считаю что это оптимальный вариант при написании чего то низкоуровневого. Но при написании именно бизнес-логики, а не инфраструктуры иногда удобней использовать модель `async\await`. Самые болезненные случаи будут рассмотрены дальше

++ Добавить обоснования из пейпера Корутин ТС

Для того чтобы начать понимание того, как все таки использовать корутины, а также интегрировать чужие начнем с простого - создадим обертку для следующей функции.

```cpp
using Callback = std::function<void(bool ok, string result)>;

void run(string request, Callback cb);

??? run_async(string request) {
    ???
}
```


Стандарт С++20 позволяет определить `coroutine_type` - объект, который являсь значением, возвращаемым из функции определеить ее как корутину.

Для этого **обязательно**:
1) присутствие одного из ключевых слов: `co_await`, `co_return`, `co_yield`.
2) наличие внутреннего типа `promise_type` (или переопределение `std::coroutine_traits`)
3) возможность получить из `coroutine_type` => `awaitable`

Во первых это очень сжатые требования. Во вторых когда открываешь их самостоятельно помимо них видишь на `cppreference`
```cpp
template<typename T>
struct task {
    struct promise_type {
        coroutine get_return_object() { return {coroutine::from_promise(*this)}; }
        std::suspend_always initial_suspend() noexcept { return {}; }
        std::suspend_always final_suspend() noexcept { return {}; }

        void return_value(T&& result) {} // Либо эта версия
        void return_void() {} // Либо эта

        void unhandled_exception() {} // вызывается внутри catch() блока.
    }
}
```

