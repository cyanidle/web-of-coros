Но подобные проблемы легко найти и исправить. Их последствия проявляются практически сразу и очевидно.
Настоящие проблемы с корутинами могу возникнуть в изза слабой связанности вызываемого асинхронного кода и 
вызывающей стороны (что конечно и хорошо). 

```cpp

task<void> some_func();

struct Action {
    Action(string data);
    task<void> run() {
        // ok
        co_await some_func();
        // is Action alive here? Who can tell...
    }
};

```

Поэтому нашему классу `task<T>` понадобится некий способ остановить исполнения и не вызываеть `handle.resume()`.
И это мы еще не синхронизируем взаимодействие между потоков. Корутины чисто в одном потоке уже удобны


TODO: Executors, context switching