Наконец перейдем к интересной части - копанию в старом коде!

Представим сферический проект в вакууме на libuv/Qt или
любом другом фреймворке/библиотеке с асинхроным eventloop.

Чаще всего для индикации завершения операции в высокоуровневых асинхронных рантаймах используется callback функция. Детали не так важны, передается ли некий `void* data` или используется полноценное стирание типов на плюсах или это простой `std::function<>`

И такой код может вполне быть успшеным и сам я считаю что это оптимальный вариант при написании чего то низкоуровневого. Но при написании именно бизнес-логики, а не инфраструктуры удобней использовать модель `async\await` (что тоже разнится от случая к случаю и это будет важно далее)

++ Добавить обоснования из пейпера Корутин ТС

Для того чтобы начать понимание того, как все таки использовать корутины, а также интегрировать чужие начнем с простого - создадим обертку для следующей функции.

```cpp
using Callback = std::function<void(bool ok, string result)>;

void run(string request, Callback cb);

??? run_async(string request) {
    ???
}
```

```cpp
struct task {
    struct promise_type {
        coroutine get_return_object() { return {coroutine::from_promise(*this)}; }
        std::suspend_always initial_suspend() noexcept { return {}; }
        std::suspend_always final_suspend() noexcept { return {}; }
        void return_value(std::string result) {

        }
        void unhandled_exception(std::exception_ptr) {}
    }
}
```