Наконец перейдем к интересной части - копанию в старом коде!

Представим сферический проект в вакууме на libuv/Qt или
любом другом фреймворке/библиотеке с асинхроным eventloop.

Чаще всего для индикации завершения операции в высокоуровневых асинхронных рантаймах используется callback функция. Детали не так важны, передается ли некий `void* data` или используется полноценное стирание типов на плюсах или это простой `std::function<>`

И такой код может вполне быть успшеным и сам я считаю что это оптимальный вариант при написании чего то низкоуровневого. Но при написании именно бизнес-логики, а не инфраструктуры удобней использовать модель `async\await` (что тоже разнится от случая к случаю и это будет важно далее)

++ Добавить обоснования из пейпера Корутин ТС

Для того чтобы начать понимание того, как все таки использовать корутины, а также интегрировать чужие начнем с простого - создадим обертку для следующей функции.

```cpp
using Callback = std::function<void(bool ok, string result)>;
void run(string request, Callback cb);

??? run_async(string request) {
    ???
}
```

Для



```cpp
template <typename Ret, typename = std::void_t<>>
struct coroutine_traits_base
{};

template <typename Ret>
struct coroutine_traits_base<Ret, std::void_t<typename Ret::promise_type>>
{
    using promise_type = typename Ret::promise_type;
};

template <typename Ret, typename... Ts>
struct coroutine_traits : coroutine_traits_base<Ret>
{};
```


```cpp
// Enable the use of std::future<T> as a coroutine type
// by using a std::promise<T> as the promise type.
template<typename T, typename... Args>
    requires(!std::is_void_v<T> && !std::is_reference_v<T>)
struct std::coroutine_traits<std::future<T>, as_coroutine, Args...>
{
    struct promise_type : std::promise<T>
    {
        std::future<T> get_return_object() noexcept
        {
            return this->get_future();
        }
 
        std::suspend_never initial_suspend() const noexcept { return {}; }
        std::suspend_never final_suspend() const noexcept { return {}; }
 
        void return_value(const T& value)
            noexcept(std::is_nothrow_copy_constructible_v<T>)
        {
            this->set_value(value);
        }
 
        void return_value(T&& value) noexcept(std::is_nothrow_move_constructible_v<T>)
        {
            this->set_value(std::move(value));
        }
 
        void unhandled_exception() noexcept
        {
            this->set_exception(std::current_exception());
        }
    };
};
```