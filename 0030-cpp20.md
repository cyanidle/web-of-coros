Наконец перейдем к интересной части - копанию в старом коде!

Представим сферический проект в вакууме на libuv/Qt или
любом другом фреймворке/библиотеке с асинхроным eventloop.

Чаще всего для индикации завершения операции в высокоуровневых асинхронных рантаймах используется callback функция. Детали не так важны, передается ли некий `void* data` или используется полноценное стирание типов на плюсах или это простой `std::function<>`

И такой код может вполне быть успшеным и сам я считаю что это оптимальный вариант при написании чего то низкоуровневого. Но при написании именно бизнес-логики, а не инфраструктуры удобней использовать модель `async\await` (что тоже разнится от случая к случаю и это будет важно далее)

++ Добавить обоснования из пейпера Корутин ТС

Для того чтобы начать понимание того, как все таки использовать корутины, а также интегрировать чужие начнем с простого - создадим обертку для следующей функции.

```cpp
using Callback = std::function<void(bool ok, string result)>;

void run(string request, Callback cb);

??? run_async(string request) {
    ???
}
```

```cpp
struct task {
    struct promise_type {
        coroutine get_return_object() { return {coroutine::from_promise(*this)}; }
        std::suspend_always initial_suspend() noexcept { return {}; }
        std::suspend_always final_suspend() noexcept { return {}; }
        void return_value(std::string result) {

        }
        void unhandled_exception(std::exception_ptr) {}
    }
}
```


Our futures
```cpp
#include <string>
#include <functional>
#include <coroutine>
#include <stdexcept>
#include <optional>
#include <concepts>
#include <memory>

using std::string;

using Callback = std::function<void(bool ok, string result)>;

void run(string request, Callback cb);
void log(string msg);

template<typename T>
struct result {

};

template<typename T>
struct future {
    using callback = std::function<void(T*, std::exception_ptr)>;
    struct state {
        callback cb;
        bool done = false;
        alignas(T) char buff[sizeof(T)];
        std::exception_ptr exc = {};
    };
    using state_ptr = std::shared_ptr<state>;
    
    future(state_ptr s) : s(s) {}
    
    void then(std::invocable<> auto fn) {
        if (!s) throw std::runtime_error("invalid future");
        s->cb = [fn = std::move(fn)](T* v, std::exception_ptr) mutable {

        };
        s = {};
    }
protected:
    state_ptr s;
};

template<typename T>
struct promise {

};
```


```cpp
template <typename Ret, typename = std::void_t<>>
struct coroutine_traits_base
{};

template <typename Ret>
struct coroutine_traits_base<Ret, std::void_t<typename Ret::promise_type>>
{
    using promise_type = typename Ret::promise_type;
};

template <typename Ret, typename... Ts>
struct coroutine_traits : coroutine_traits_base<Ret>
{};
```
